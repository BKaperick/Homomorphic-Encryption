\documentclass[a4paper,11pt, oneside]{article}
\usepackage{C:/Programs/Vim/TiaStyle}
\input{C:/Programs/Vim/style.tex}

\newcommand{\C}[1]{\mathcal{C}_{#1}}
\renewcommand{\D}{\mathcal{D}_{\gamma,\rho}(p)}
\newcommand{\ring}{\mathcal{S}}
\newcommand{\nring}{\mathcal{S}_n}
\title{Analysis of Somewhat Homomorphic Encryption Over the Integer Ring}
\author{Bryan Kaperick}

\begin{document}
\maketitle\newpage
\section{Preliminaries}
\subsection{Symmetric Modulus}
Traditionally, the modulus operator can be defined as follows
\begin{definition}
  Define $q_a(b) = \floor{\frac{b}{a}}$.  Then, define $a\mod{b} = a - q_a(b)b$, which is equivalent to setting $a\mod{b}$ to be the representative in $[0,b)$ for the residue class containing $a$ for the congruence relation of congruence modulo $b$.
\end{definition}

However, for the purposes of this paper, it will be seen that a slightly altered definition is much more convenient.
\begin{definition}
  Define $q_a(b) = \round{\frac{a}{b}}$, where $\round{\cdot}$ returns the nearest integer to the input value (rounding up for multiples of one-half).  Again, define $a\mod{b} = b - q_a(b)a$.  
\end{definition}

While notationally annoying, this approach makes much more sense once the \emph{idea} of this scheme is understood.  In general, the scheme relies on recovering a noisy approximation of a multiple of the secret key, so in this respect, it is more natural to allow a symmetric distribution of noisy approximations to all be in the same \emph{class}.  More on this later.

\subsection{Rounding Operator}

In these notes it is often necessary to round a number to the nearest integer.  The following notation is used,
\begin{definition}
  Let $x\in\R$.  Then, $\round{x}$ is equal to the integer closest to $x$ (rounding down if equidistant).
\end{definition}

\section{Goals of Scheme}
This scheme is intended to be a homomorphic encryption scheme equipped to allow evaluation of the encrypted data on arbitrary binary addition and multiplication circuits (up to a pre-determined depth) such that the evaluated data almost surely decrypts correctly.  

\section{Motivation for Approach}
The main idea is to map a bit to an arbitrary integer multiple of the secret key --- also an integer --- with some additional noise added.  Let $\ring$ be the space of integer multiples of the secret key, $s$.  Let $x,y\in \ring$.  Observe that with integer addition and multiplication, $\ring$ forms a ring.

\begin{proof}
  $\ring = \left\{ x | \exists n\in \Z, x = n\cdot s\right\}$.  Let $x,y\in \ring$. If $x = n\cdot s$ and $y = m\cdot s$ for some $n,m\in\Z$, then clearly $x+y = n\cdot s + m\cdot s = (n+m)\cdot s$, so the operation is closed.  Integer addition is commutative.  Every integer $n\in \Z$ has additive inverse $-n$, and both $n\cdot s$ and $-n\cdot s$ are in $\ring$.  Clearly $0\cdot s$ is in $\ring$, satisfying conditions for the identity.  Thus, $\ring$ is a group under addition.  
  
  Multiplication is also closed with respect to the integers, is associative and distributes over addition.  $1$ satisfies as the identity element.  Thus, multiplication acts as the second binary operation, and $(\ring, +, \cdot)$ is a ring.
\end{proof}

This fact is the foundational motivation behind this scheme.  Since adding and multiplying elements of $\ring$ will also be elements of $\ring$, so the goal is to develop a scheme which maps these operations of $\ring$ to the equivalent operations on the unencrypted bits corresponding to those elements of $\ring$.  The security of the scheme comes from adding noise to the elements of $\ring$ to make the act of retrieving $s$ difficult.

\subsection{Noisy Ring $\nring$}

To formalize the notion of noise in this ring, we will discuss a new ring, $\nring$.  First, we begin with the set of integers, $\Z$.  We define a congruence relation on $\Z$,
\begin{definition}
    Fix $s\in\Z^+$.  Let $a,b\in \Z$.  We will say $a$ is equivalent to $b$, or $a\equiv b$, if $q_s(a) = q_s(b)$.  That is, if $\round{\frac{a}{s}} = \round{\frac{b}{s}}$.  This is equivalent to defining the relation as the following:  Decompose $a$ and $b$ into $a = xs + n$ and $b = ys + m$ for some $x,y\in\Z$ and $m,n\in ( -s/2, s/2]$.  Then, $a\equiv b$ if and only if $x = y$.
\end{definition}

This relation clearly satisfies symmetry, reflexivity and transitivity.  The equivalency classes of this relation partition $\Z$ into neighborhoods around each multiple of $s$.  This can be enumerated by denoting $\mathcal{C}_i$ to be the equivalency class around $i\cdot s$, so
\[\Z= \bigcup_{i\in\Z} \C{i}.\]
Now, let $\nring$ be the set of these equivalency classes.  
\[\nring = \left\{\dots,\, \C{-2},\,\C{-1},\,\C{0},\,\C{1},\,\C{2},\dots \right\} .\]
Now, define the following binary operations, $\oplus$ and $\odot$.
\begin{definition}
    Let $\C{i},\C{j}\in\nring$ be equivalency classes as described above.  Then, define this operation as $\C{i} \oplus \C{j} = \C{i+j}$.
\end{definition}

\begin{definition}
    Let $\C{i},\C{j}\in\nring$ be equivalency classes as described above.  Then, define this operation as $\C{i} \odot \C{j} = \C{i\cdot j}$.
\end{definition}

Since both operations return elements of $\nring$, they are both closed.  It is simple to show that these satisfy the necessary conditions to make $\left(\nring, \oplus, \odot\right)$ a ring.

This structure will serve as a stronger model for discussing the encryption scheme.  The $\oplus$ and $\odot$ operators mimic the interaction of two integers near a multiple of $s$.

\section{Implementation}
    \subsection{Special Distribution, $\D$}
    We define $\D$ and analyze it prior to discussing the encryption scheme.  We define $\D$,
\begin{definition}
    Let $s\in\Z$ be odd and positive.  Now define the distribution of interest as
    \[
        \D = \{ \text{choose}\, q\leftarrow\Z\cap[0,2^\gamma/s),\quad r\leftarrow \Z\cap (-2^{\rho}, 2^\rho),\quad\text{output}\, x = sq+r\}.
        \] 
\end{definition}

Random variables drawn from $\D$ are simply noisy multiples of $s$ with certain size restrictions. $r$ is the \emph{noise parameter}, with $\rho$ dictating the size, in bits of $r$.  Notice it is evenly distributed over $sq$.  Since for $x\leftarrow\D$, $x = sq+r$, if $\rho = 0$ then $r = 0$ so $x\in\ring$.  However, with nonzero noise, we see that if $x = sq+r$, then $x\in\C{q}\in\nring$.  So, this distribution can be seen as choosing a random element of $\nring$ and then a random element within a subset of that equivalency class.  

The noise level determines how far from the nearest multiple of $s$ an element from $\D$ can be.

    \subsection{Overview of Scheme}
    First, $\lambda$, the security parameter is set.  Then, the following parameters are set
\begin{itemize}
    \item[$\gamma$] is the bit-length of the integers in the public key, 
    \item[$\nu$] is the bit-length of the secret key (which is the hidden approximate-gcd of all the public-key integers), 
    \item[$\rho$] is the bit-length of the noise (i.e., the distance between the public key elements and the nearest multiples of the secret key), and 
    \item[$\tau$] is the number of integers in the public key.
\end{itemize}

Then, the \texttt{KeyGen}, \texttt{Encrypt}, \texttt{Decrypt}, and $\texttt{Evaluate}$ functions can be described in terms of these, and the input bit, $m\in\{0,1\}$.

\subsubsection{\texttt{KeyGen}}
The first step is to create the public key, $p$ and the secret key, $s$.  We define $s$ to be an odd $\nu$-bit integer, so
\[ s\leftarrow (2\Z + 1)\cap [2^{\nu - 1}, 2^\nu).\]


To create the public key, we start by sampling $\D$ with $x_i \leftarrow \D$ for all $i=0,1,\dots,\tau$.  Relabel to ensure $x_0$ is the largest.  Restart this process until $x_0$ is odd and $x_0\mod{s}$ is even.  Then, $p = <x_0,\dots,x_\tau>$.
    
\subsubsection{\texttt{Encrypt}}

Given a bit $m\in\{0,1\}$, we first choose a random subset $S\subseteq \{1,2,\dots,\tau\}$ and random realization $r\leftarrow (-2^{\rho'},2^{\rho'})$.  The encrypted integer, $c$ is defined
\[c = \left( m+2r + \sum_{i\in S}x_i \right)\mod{x_0}.\]

A discussion of why this works is in \ref{sec:proof}.

\subsubsection{\texttt{Decrypt}}
Given an integer $c$ which has been encrypted by this scheme, it can be unencrypted by setting
\[m = c\mod{s}\mod{2}.\]
And $m$ is the unencrypted bit.

\subsubsection{\texttt{Evaluate}}
Performing integer addition and multiplication on the encrypted values and then decrypting returns the equivalent binary addition and multiplication on the original bits.

\subsection{Proof of Validity}\label{sec:proof}
The $\texttt{KeyGen}$ produces a large odd integer, $s$ and a public key as a tuple of near-multiples of $s$, $<x_0,x_1,\dots,x_\tau>$.  $x_0$ is the largest of the publik key elements, and $x_0$ is odd and satisfies $x_0\mod{s}\mod{2} = 0$.


The scheme perfectly decrypts if \texttt{Decrypt} is the left inverse of $\texttt{Encrypt}$.  That is, for an arbitrary $m\in\{0,1\}$, \texttt{Decrypt}$($\texttt{Encrypt}$(m)) = m$.

So, we claim the following,
\begin{theorem}
    With sufficiently small noise, the above scheme perfectly decrypts any arbitrary $m\in\{0,1\}$.
    \label{perfect}
\end{theorem}


\begin{proof}

    Suppose $m\in\{0,1\}$ has been encrypted with $\texttt{Evaluate}$ using $s$ and $<x_0,x_1,\dots,x_\tau>$ is the private and public keys, respectively.  Since each element of the public key is a noisy multiple of $s$, we can rewrite the public key elements as 
\begin{align*}
    x_0 &= c_0s+r_0\\
    x_1 &= c_1s+r_1\\
    &\vdots\\
    x_\tau &= c_\tau s+r_\tau.
\end{align*}

Subject to the constraints
\begin{itemize}
    \item $c_i\in\Z$
    \item $r_i\in (-2^\rho,2^\rho)\subseteq \left( -\frac{s-1}{2}, \frac{s-1}{2} \right)$
    \item $c_0s + r_0 \geq c_is+r_i$
    \item $r_0$ is odd
    \item $c_0$ is even
\end{itemize}
for all $ 0 \leq i \leq \tau$.

To encrypt $m$, a subset of the public key indices is chosen randomly.  Let $\alpha_1,\alpha_2,\dots,\alpha_n$, $0 < \alpha_i \leq \tau$ for all $0 < i \leq n$ be the indices of the subset chosen.  Finally, more noise is added as $r_e \leftarrow (-2^{\rho'}, 2^{\rho'})$.
\[c = m + 2r_e + 2\sum_{i=0}^n x_{\alpha_i}\mod{x_0}\]
Then, to decrypt, 
\[m' = c\mod{s}\mod{2}.\]

    \[c = m + 2r_e + 2\sum_{i=0}^n x_{\alpha_i}\mod{x_0}\]
    Let $r = r_e + r_0 + \sum_{i=1}^nr_{\alpha_i}.$ Now, with the definition of $\mod{\cdot}$,
    \begin{align*}
        c &= m + 2r_e + 2\sum_{i=0}^n x_{\alpha_i}\mod{x_0}\\
        &= m + 2r + 2\sum_{i=0}^n c_{\alpha_i}s\mod{x_0}\\
        &= m + 2\left( r + s\sum_{i=0}^n c_{\alpha_i}\right)\mod{x_0}\\
        &= m + 2\left( r + s\sum_{i=0}^n c_{\alpha_i}\right) - \round{\frac{m + 2r + 2\sum_{i=0}^nc_{\alpha_i}s}{x_0}}(x_0)\\
    \end{align*}

Now, applying the first step of decryption to $c$, we have
    \begin{align*}
        c\mod{s} &= m + 2\left( r + s\sum_{i=0}^n c_{\alpha_i}\right) - \round{\frac{m + 2r + 2\sum_{i=0}^nc_{\alpha_i}s}{x_0}}(x_0)\mod{s}\\
                 &= m + 2\left( r + s\sum_{i=0}^n c_{\alpha_i}\right) - \round{\frac{m + 2r + 2\sum_{i=0}^nc_{\alpha_i}s}{x_0}}(c_0s+r_0)\mod{s}
    \end{align*}
    and since any multiple of $s$ reduces to $0\mod{s}$, this simplies to
    \[c\mod{s} = m + 2r - \round{\frac{m + 2r + 2\sum_{i=0}^nc_{\alpha_i}s}{x_0}}r_0\mod{s}.\]

    Now, if
    \[ \left| 2r - \round{\frac{m + 2r + 2\sum_{i=0}^nc_{\alpha_i}s}{x_0}}r_0\right| < |s/2|-1,\]
    then
    \[c\mod{s} = m + 2\left(r - \round{\frac{m + 2r + 2\sum_{i=0}^nc_{\alpha_i}s}{x_0}}\frac{r_0}{2}\right).\]
    Thus, $c\mod{s}\mod{2} = m$, as desired.  
\end{proof}


\section{Attacks}

\subsection{Least Significant Bit Guessing}
\subsection{Solving Approximate GCD}



\end{document}

